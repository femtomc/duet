//! Reaction definitions and effects for the runtime.
//!
//! A reaction subscribes to a dataspace pattern and emits deterministic side
//! effects when matches occur. Reactions are scoped to the facet that
//! registered them and execute within the same activation, ensuring
//! compatibility with time-travel and replay.

use super::pattern::{Pattern, PatternMatch};
use super::registry::preserves_text_serde;
use super::turn::{ActorId, FacetId};
use chrono::{DateTime, Utc};
use preserves::IOValue;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use uuid::Uuid;

/// Identifier for a reaction definition.
pub type ReactionId = Uuid;

/// Side-effects produced when a reaction fires.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "kebab-case")]
pub enum ReactionEffect {
    /// Assert a value (which may reference the match) into the dataspace.
    Assert {
        /// Value to assert.
        value: ReactionValue,
        /// Target facet (defaults to the pattern facet when omitted).
        #[serde(skip_serializing_if = "Option::is_none")]
        target_facet: Option<FacetId>,
    },
    /// Send a message to another actor/facet.
    SendMessage {
        /// Target actor.
        actor: ActorId,
        /// Target facet.
        facet: FacetId,
        /// Message payload.
        payload: ReactionValue,
    },
}

/// Reaction values can be literal preserves values or derived from the match.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "kebab-case")]
pub enum ReactionValue {
    /// Use a literal preserves value.
    Literal {
        /// Preserves value to assert or emit.
        #[serde(with = "preserves_text_serde")]
        value: IOValue,
    },
    /// Use the full matched value.
    Match,
    /// Use the nth element of the matched value (record or sequence).
    MatchIndex {
        /// Zero-based index to extract.
        index: usize,
    },
}

/// Fully materialised reaction definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReactionDefinition {
    /// Stable identifier for this reaction.
    pub id: ReactionId,
    /// Pattern subscribed by the reaction.
    pub pattern: Pattern,
    /// Effect executed whenever the pattern matches.
    pub effect: ReactionEffect,
}

impl ReactionDefinition {
    /// Create a new definition with an autogenerated identifier.
    pub fn new(pattern: Pattern, effect: ReactionEffect) -> Self {
        Self {
            id: ReactionId::new_v4(),
            pattern,
            effect,
        }
    }
}

impl ReactionValue {
    /// Resolve the reaction value for a particular pattern match.
    pub fn resolve(&self, pattern_match: &PatternMatch) -> Option<IOValue> {
        match self {
            ReactionValue::Literal { value } => Some(value.clone()),
            ReactionValue::Match => Some(pattern_match.value.clone()),
            ReactionValue::MatchIndex { index } => {
                let source = &pattern_match.value;
                if source.is_record() || source.is_sequence() {
                    if *index < source.len() {
                        let extracted = source.index(*index);
                        Some(IOValue::from(extracted))
                    } else {
                        None
                    }
                } else {
                    None
                }
            }
        }
    }
}

/// Persistent registry of reaction definitions.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ReactionStore {
    entries: HashMap<ReactionId, StoredReaction>,
}

/// Serializable record of a reaction tied to an actor.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StoredReaction {
    /// Stable identifier for the reaction.
    pub reaction_id: ReactionId,
    /// Actor hosting the reaction.
    pub actor: ActorId,
    /// Reaction definition executed within the actor.
    pub definition: ReactionDefinition,
}

/// Runtime statistics collected for each reaction.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ReactionStats {
    /// Number of successful executions.
    pub trigger_count: u64,
    /// Time of the last execution (success or failure).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_trigger: Option<DateTime<Utc>>,
    /// Last error message, if any.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_error: Option<String>,
}

impl ReactionStats {
    /// Record a successful execution.
    pub fn record_success(&mut self) {
        self.trigger_count += 1;
        self.last_trigger = Some(Utc::now());
        self.last_error = None;
    }

    /// Record a failed execution.
    pub fn record_error(&mut self, error: String) {
        self.last_error = Some(error);
        self.last_trigger = Some(Utc::now());
    }
}

/// Snapshot returned to callers when listing reactions.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReactionInfo {
    /// Stable identifier of the reaction.
    pub reaction_id: ReactionId,
    /// Actor that owns the reaction.
    pub actor: ActorId,
    /// Full reaction definition.
    pub definition: ReactionDefinition,
    /// Runtime statistics collected for the reaction.
    #[serde(default)]
    pub stats: ReactionStats,
}

impl ReactionStore {
    /// Create an empty reaction store.
    pub fn new() -> Self {
        Self {
            entries: HashMap::new(),
        }
    }

    /// Load reactions from disk, returning an empty store if the file is absent.
    pub fn load(path: &Path) -> Result<Self, std::io::Error> {
        if path.exists() {
            let data = std::fs::read(path)?;
            let entries: HashMap<ReactionId, StoredReaction> =
                serde_json::from_slice(&data).map_err(json_error)?;
            Ok(Self { entries })
        } else {
            Ok(Self::new())
        }
    }

    /// Persist the store to disk, creating parent directories as needed.
    pub fn save(&self, path: &Path) -> Result<(), std::io::Error> {
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        let data = serde_json::to_vec_pretty(&self.entries).map_err(json_error)?;
        std::fs::write(path, data)
    }

    /// Insert or replace a stored reaction.
    pub fn insert(&mut self, entry: StoredReaction) {
        self.entries.insert(entry.reaction_id, entry);
    }

    /// Remove a stored reaction by identifier.
    pub fn remove(&mut self, reaction_id: &ReactionId) -> Option<StoredReaction> {
        self.entries.remove(reaction_id)
    }

    /// Retrieve a stored reaction by identifier.
    pub fn get(&self, reaction_id: &ReactionId) -> Option<&StoredReaction> {
        self.entries.get(reaction_id)
    }

    /// Iterate over all stored reactions.
    pub fn iter(&self) -> impl Iterator<Item = (&ReactionId, &StoredReaction)> {
        self.entries.iter()
    }
}

fn json_error(err: serde_json::Error) -> std::io::Error {
    std::io::Error::new(std::io::ErrorKind::InvalidData, err)
}

#[cfg(test)]
mod tests {
    use super::super::turn::Handle;
    use super::*;

    #[test]
    fn reaction_value_match_resolves() {
        let value: IOValue = "\"hello\"".parse().unwrap();
        let pattern_match = PatternMatch {
            pattern_id: Uuid::new_v4(),
            handle: Handle::new(),
            value: value.clone(),
        };

        let resolved = ReactionValue::Match.resolve(&pattern_match);
        assert_eq!(resolved, Some(value));
    }

    #[test]
    fn reaction_value_literal_resolves() {
        let literal = IOValue::symbol("test");
        let pattern_match = PatternMatch {
            pattern_id: Uuid::new_v4(),
            handle: Handle::new(),
            value: "42".parse().unwrap(),
        };

        let resolved = ReactionValue::Literal {
            value: literal.clone(),
        }
        .resolve(&pattern_match);
        assert_eq!(resolved, Some(literal));
    }

    #[test]
    fn reaction_value_match_index_resolves() {
        let pattern_match = PatternMatch {
            pattern_id: Uuid::new_v4(),
            handle: Handle::new(),
            value: IOValue::record(
                IOValue::symbol("rec"),
                vec![IOValue::new(1_i64), IOValue::new(2_i64)],
            ),
        };

        let resolved = ReactionValue::MatchIndex { index: 1 }.resolve(&pattern_match);
        assert_eq!(resolved, Some(IOValue::new(2_i64)));
    }
}
